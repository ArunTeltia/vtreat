---
title: "Multi Class vtreat"
author: "John Mount"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multi Class vtreat}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

Problem: try to prepare data to model multi-class y as a function of x using [`vtreat`](https://github.com/WinVector/vtreat). `vtreat` does not directly do this, but can be used to do this.  In this note we share functions to make this adaption.

```{r libs}
library("vtreat")
```

Pretend the next two functions are defined elsewhere (i.e. already
available from a package).

```{r fns}
#' Function to build multi-outcome vtreat cross frame and treatment plan.
#' 
#' @param d data to learn from
#' @param vars character, vector of indpendent variable column names.
#' @param y_name character, name of outcome column.
#' @param y_dependent_treatments character what treatment types to build per-outcome level.
#' @return list(cross_frame, treatments_0, treatments_m)
mk_mult_cross_frame_c <- function(d, vars, y_name, 
                                  y_dependent_treatments = c("catB")) {
  # build y-independent variable treatments
  treatments_0 <- designTreatmentsZ(d, vars, 
                                    verbose = FALSE)
  
  # build one set of y-dependent treatments per possible y outcome
  cfe_list <- lapply(
    y_levels,
    function(y_target) {
      cfe <- mkCrossFrameCExperiment(
        d, vars, y_name, y_target,
        codeRestriction = y_dependent_treatments,
        verbose = FALSE)
      cross_frame_i = cfe$crossFrame
      cross_frame_i[[y_name]] <- NULL
      colnames(cross_frame_i) <- paste0(y_target, 
                                        "_", 
                                        colnames(cross_frame_i))
      list(treatments_i = cfe$treatments,
           cross_frame_i = cross_frame_i)
    })
  names(cfe_list) <- y_levels
  
  # build an overall cross-frame for training
  dy <- data.frame(y = as.character(d[[y_name]]),
                   stringsAsFactors = FALSE)
  cross_frame <- do.call(
    cbind,
    c(prepare(treatments_0, d),
      lapply(cfe_list, function(cfei) cfei$cross_frame_i),
      dy,
      stringsAsFactors = FALSE))
  
  # build a prepare function for new data
  treatments_m <- lapply(cfe_list, function(cfei) cfei$treatments_i)
  # return components
  list(cross_frame = cross_frame,
       treatments_0 = treatments_0,
       treatments_m = treatments_m)
}

#' Function to apply mk_mult_cross_frame_c treatemnts.
#' 
#' @param new_d new data to process.
#' @param treatments_0 element from mk_mult_cross_frame_c return.
#' @param treatments_m element from mk_mult_cross_frame_c return.
#' @return prepared data frame.
prepare_m <- function(new_d, treatments_0, treatments_m) {
  y_name <- treatments_m[[1]]$outcomename
  treated <- prepare(treatments_0, new_d)
  for(ti in treatments_m) {
    treated_i <- prepare(ti, new_d)
    treated_i[[y_name]] <- NULL
    colnames(treated_i) <- paste0(ti$outcomeTarget, 
                                  "_", 
                                  colnames(treated_i))
    treated <- cbind(treated, treated_i,
                     stringsAsFactors = FALSE)
  }
  if(y_name %in% colnames(new_d)) {
    treated[[y_name]] <- new_d[[y_name]]
  }
  treated
}
```

Our specific example: try to model multi-class y as a function of x1 and x2

```{r mkex}
# create example data
set.seed(326346)
sym_bonuses <- rnorm(3)
names(sym_bonuses) <- c("a", "b", "c")
n_row <- 1000
d <- data.frame(x1 = rnorm(n_row),
                x2 = sample(names(sym_bonuses), n_row, replace = TRUE),
                y = "NoInfo",
                stringsAsFactors = FALSE)
d$y[d$x1 > sym_bonuses[d$x2] + runif(n_row)] <- "Large1"
d$y[sym_bonuses[d$x2] > d$x1 + runif(n_row)] <- "Large2"

knitr::kable(head(d))
```

We define the problem controls and use `mk_mult_cross_frame_c()` to build both a cross-frame and
a treatment plan.

```{r tdef}
# define problem
vars <- c("x1", "x2")
y_name <- "y"
y_levels <- sort(unique(d[[y_name]]))

# build the multi-class cross frame and treatments
cfe_m <- mk_mult_cross_frame_c(d, vars, y_name)
```

The cross-frame is the entity safest for training on (unless you have made separate data split for the 
treatment design step). It uses cross-validation to reduce nested model bias. Some notes on this issue
are available [here](https://winvector.github.io/vtreat/articles/vtreatCrossFrames.html), and [here](https://github.com/WinVector/vtreat/blob/master/extras/vtreat.pdf).

```{r crossframe}
# look at the data we would train models on
str(cfe_m$cross_frame)
```

`prepare_m()` is a function that can apply the designed treatments to new data.  Here we are simulating new 
data by re-using our design data.

```{r treatment plan}
# pretend original data is new data to be treated
str(prepare_m(d, 
               cfe_m$treatments_0, cfe_m$treatments_m))
```

Obvious issues include: computing variable significances, and blow up and co-dependency of produced columns.  These we leave for the next modeling step to deal with (this is our philosophy with most issues that involve joint distributions of variables).


